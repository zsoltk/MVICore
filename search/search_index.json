{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MVICore \u00b6 What's this? \u00b6 MVICore is a modern MVI framework featuring: 100% Kotlin : An easy way to implement your business features in a reactive way with unidirectional dataflow Scaling with complexity : operate with a single Reducer if needed, with the option of having the full power of additional components to handle more complex cases Event handling : A solution to handling events that you don\u2019t want to store in the state Reactive component binding : A super simple API to bind your reactive endpoints to each other with automatic lifecycle handling Custom Middlewares : for every single component in the system, with flexible configuration options Logger : An out-of-the-box logger Middleware Time Travel Debugger : for ALL of your reactive components (not just your state machine!) with UI controls for recording and playback The big picture \u00b6 1. Create your state machine \u00b6 class SimpleFeature : ReducerFeature < Wish , State , Nothing >( initialState = State (), reducer = ReducerImpl () ) { // Define your immutable state as a Kotlin data class data class State ( val counter : Int = 0 ) // Define the ways it could be affected sealed class Wish { object IncreaseCounter : Wish () data class MultiplyBy ( val value : Int ) : Wish () } // Define your reducer class ReducerImpl : Reducer < State , Wish > { override fun invoke ( state : State , wish : Wish ): State = // Leverage the power of exhaustive when over Kotlin sealed classes when ( wish ) { // Create the next state based on the current one IncreaseCounter -> state . copy ( counter = state . counter + 1 ) // Create the next state based on the current one is MultiplyBy -> state . copy ( counter = state . counter * wish . value ) } } } Note Feature has additional components to solve problems like side-effects, events, initialisation, internal jobs in a standardised way. For a full list check Features section to see what's possible. 2. Your state machine is reactive \u00b6 val feature = SimpleFeature () // Now you can observe and subscribe to its state changes: Observable . wrap ( feature ). subscribe { state -> TODO () } // And it's also a Consumer of Wishes. Trigger some state changes: Observable . just ( Wish . IncreaseCounter ). subscribe ( feature ) Actually, don't use it the above way ! We can do so much better: 3. Use the Binder \u00b6 For connecting your reactive components. Comes with automatic lifecycle handling and invoking transformations: val binder = Binder ( lifecycle ) binder . bind ( view to feature using ViewEventToWish ) binder . bind ( feature to view using StateToViewModel ) Download \u00b6 Available through jitpack. Add the maven repo to your root build . gradle allprojects { repositories { maven { url 'https://jitpack.io' } } } Add the dependencies: Framework: implementation 'com.github.badoo.mvicore:mvicore:{latest-version}' Helper classes for Android: implementation 'com.github.badoo.mvicore:mvicore-android:{latest-version}' Time Travel Debugger controls in a DebugDrawer module (You need to add the dependencies to DebugDrawer and configure it yourself before you can use this): implementation 'com.github.badoo.mvicore:mvicore-debugdrawer:{latest-version}'","title":"Overview"},{"location":"#mvicore","text":"","title":"MVICore"},{"location":"#whats-this","text":"MVICore is a modern MVI framework featuring: 100% Kotlin : An easy way to implement your business features in a reactive way with unidirectional dataflow Scaling with complexity : operate with a single Reducer if needed, with the option of having the full power of additional components to handle more complex cases Event handling : A solution to handling events that you don\u2019t want to store in the state Reactive component binding : A super simple API to bind your reactive endpoints to each other with automatic lifecycle handling Custom Middlewares : for every single component in the system, with flexible configuration options Logger : An out-of-the-box logger Middleware Time Travel Debugger : for ALL of your reactive components (not just your state machine!) with UI controls for recording and playback","title":"What's this?"},{"location":"#the-big-picture","text":"","title":"The big picture"},{"location":"#1-create-your-state-machine","text":"class SimpleFeature : ReducerFeature < Wish , State , Nothing >( initialState = State (), reducer = ReducerImpl () ) { // Define your immutable state as a Kotlin data class data class State ( val counter : Int = 0 ) // Define the ways it could be affected sealed class Wish { object IncreaseCounter : Wish () data class MultiplyBy ( val value : Int ) : Wish () } // Define your reducer class ReducerImpl : Reducer < State , Wish > { override fun invoke ( state : State , wish : Wish ): State = // Leverage the power of exhaustive when over Kotlin sealed classes when ( wish ) { // Create the next state based on the current one IncreaseCounter -> state . copy ( counter = state . counter + 1 ) // Create the next state based on the current one is MultiplyBy -> state . copy ( counter = state . counter * wish . value ) } } } Note Feature has additional components to solve problems like side-effects, events, initialisation, internal jobs in a standardised way. For a full list check Features section to see what's possible.","title":"1. Create your state machine"},{"location":"#2-your-state-machine-is-reactive","text":"val feature = SimpleFeature () // Now you can observe and subscribe to its state changes: Observable . wrap ( feature ). subscribe { state -> TODO () } // And it's also a Consumer of Wishes. Trigger some state changes: Observable . just ( Wish . IncreaseCounter ). subscribe ( feature ) Actually, don't use it the above way ! We can do so much better:","title":"2. Your state machine is reactive"},{"location":"#3-use-the-binder","text":"For connecting your reactive components. Comes with automatic lifecycle handling and invoking transformations: val binder = Binder ( lifecycle ) binder . bind ( view to feature using ViewEventToWish ) binder . bind ( feature to view using StateToViewModel )","title":"3. Use the Binder"},{"location":"#download","text":"Available through jitpack. Add the maven repo to your root build . gradle allprojects { repositories { maven { url 'https://jitpack.io' } } } Add the dependencies: Framework: implementation 'com.github.badoo.mvicore:mvicore:{latest-version}' Helper classes for Android: implementation 'com.github.badoo.mvicore:mvicore-android:{latest-version}' Time Travel Debugger controls in a DebugDrawer module (You need to add the dependencies to DebugDrawer and configure it yourself before you can use this): implementation 'com.github.badoo.mvicore:mvicore-debugdrawer:{latest-version}'","title":"Download"},{"location":"bestpractices/","text":"FAQ & Best practices \u00b6 I. Feature disposal \u00b6 Never forget to call feature . dispose () when the context your Feature is living in goes away! II. Keep your Reducers dumb \u00b6 The idea is that Reducer should contain only resolution to how an Effect modifies the State directly. class ReducerImpl : Reducer < State , Effect > { override fun invoke ( state : State , effect : Effect ): State = when ( effect ) { // This is fine: is Effect1 -> state . copy ( someFlag = true ) is Effect2 -> state . copy ( someData = effect . data ) is Effect3 -> state . copy ( counter = state . counter + 1 ) // Don't do this: is Effect4 -> if ( someCondition ) ( someFlag = true ) else state . copy ( counter = state . counter + 1 ) } } If you find yourself adding conditionals, it's a smell that probably business logic is creeping from your Actor to your Reducer . Resolution: Actor is the intended place for business logic: Create Effects with meaningful names to describe what can happen to your State Decide what happens inside your Actor , based on any conditional logic or async execution, and emit the corresponding Effects Use your Reducer only to implement how it modifies the State III. Effects only in Actor \u00b6 Once the complexity grows inside your Actor , you might be tempted to extract some responsibilities to other classes. This is fine, however, don't do this: class ActorImpl ( private val executor1 : Executor1 , private val executor2 : Executor2 ) : Actor < State , Wish , Effect > { override fun invoke ( state : State , wish : Wish ): Observable < Effect > = when ( wish ) { is Wish1 -> executor1 . doSomething () is Wish2 -> executor2 . doSomething () } } // In some other files: class Executor1 { fun doSomething (): Observable < Effect > = TODO () } class Executor2 { fun doSomething (): Observable < Effect > = TODO () } This way the reader of your code can have no simple understanding of what Effect is the result of what and where. Resolution: Keep your Effects internal to your Feature In your extracted classes use only local result types Map those results to Effects in your Actor , ensuring that all business logic is understandable in a high-level overview in one place. Example: class ActorImpl ( private val executor1 : Executor1 , private val executor2 : Executor2 ) : Actor < State , Wish , Effect > { override fun invoke ( state : State , wish : Wish ): Observable < Effect > = when ( wish ) { is Wish1 -> executor1 . doSomething () . map { when ( it ) { is SomethingHappened1 -> Effect1 ( it . data ) is SomethingHappened2 -> Effect2 }} is Wish2 -> executor2 . doSomething () . map { when ( it ) { is SomethingElseHappened1 -> Effect3 is SomethingElseHappened2 -> Effect4 ( it . error ) }} } } // In some other files: class Executor1 { fun doSomething (): Observable < LocalResult > = TODO () sealed class LocalResult { data class SomethingHappened1 ( val data : Any ) : LocalResult () object SomethingHappened2 : LocalResult () } } class Executor2 { fun doSomething (): Observable < LocalResult > = TODO () sealed class LocalResult { object SomethingElseHappened1 : LocalResult () data class SomethingElseHappened2 ( val error : Throwable ) : LocalResult () } } IV. Feature to Feature binding \u00b6 If one of your Features should always react to when something happens in another, you can use the Bootstrapper for this: class Feature2 ( feature1 : Feature1 ) : ActorReducerFeature < Wish , Effect , State , Nothing >( bootstrapper = BootstrapperImpl ( feature1 ), // remainder omitted ) { class BootstrapperImpl ( private val feature1 : Feature1 ) : Bootstrapper < Wish > { override fun invoke (): Observable < Wish > = feature1 . news . map { SomeWishOfFeature2 } } // remainder omitted This assumes that Feature1 lives longer than Feature2 . If this is not the case, you could still connect them with Binder . bind () .","title":"Best practices"},{"location":"bestpractices/#faq-best-practices","text":"","title":"FAQ &amp; Best practices"},{"location":"bestpractices/#i-feature-disposal","text":"Never forget to call feature . dispose () when the context your Feature is living in goes away!","title":"I. Feature disposal"},{"location":"bestpractices/#ii-keep-your-reducers-dumb","text":"The idea is that Reducer should contain only resolution to how an Effect modifies the State directly. class ReducerImpl : Reducer < State , Effect > { override fun invoke ( state : State , effect : Effect ): State = when ( effect ) { // This is fine: is Effect1 -> state . copy ( someFlag = true ) is Effect2 -> state . copy ( someData = effect . data ) is Effect3 -> state . copy ( counter = state . counter + 1 ) // Don't do this: is Effect4 -> if ( someCondition ) ( someFlag = true ) else state . copy ( counter = state . counter + 1 ) } } If you find yourself adding conditionals, it's a smell that probably business logic is creeping from your Actor to your Reducer . Resolution: Actor is the intended place for business logic: Create Effects with meaningful names to describe what can happen to your State Decide what happens inside your Actor , based on any conditional logic or async execution, and emit the corresponding Effects Use your Reducer only to implement how it modifies the State","title":"II. Keep your Reducers dumb"},{"location":"bestpractices/#iii-effects-only-in-actor","text":"Once the complexity grows inside your Actor , you might be tempted to extract some responsibilities to other classes. This is fine, however, don't do this: class ActorImpl ( private val executor1 : Executor1 , private val executor2 : Executor2 ) : Actor < State , Wish , Effect > { override fun invoke ( state : State , wish : Wish ): Observable < Effect > = when ( wish ) { is Wish1 -> executor1 . doSomething () is Wish2 -> executor2 . doSomething () } } // In some other files: class Executor1 { fun doSomething (): Observable < Effect > = TODO () } class Executor2 { fun doSomething (): Observable < Effect > = TODO () } This way the reader of your code can have no simple understanding of what Effect is the result of what and where. Resolution: Keep your Effects internal to your Feature In your extracted classes use only local result types Map those results to Effects in your Actor , ensuring that all business logic is understandable in a high-level overview in one place. Example: class ActorImpl ( private val executor1 : Executor1 , private val executor2 : Executor2 ) : Actor < State , Wish , Effect > { override fun invoke ( state : State , wish : Wish ): Observable < Effect > = when ( wish ) { is Wish1 -> executor1 . doSomething () . map { when ( it ) { is SomethingHappened1 -> Effect1 ( it . data ) is SomethingHappened2 -> Effect2 }} is Wish2 -> executor2 . doSomething () . map { when ( it ) { is SomethingElseHappened1 -> Effect3 is SomethingElseHappened2 -> Effect4 ( it . error ) }} } } // In some other files: class Executor1 { fun doSomething (): Observable < LocalResult > = TODO () sealed class LocalResult { data class SomethingHappened1 ( val data : Any ) : LocalResult () object SomethingHappened2 : LocalResult () } } class Executor2 { fun doSomething (): Observable < LocalResult > = TODO () sealed class LocalResult { object SomethingElseHappened1 : LocalResult () data class SomethingElseHappened2 ( val error : Throwable ) : LocalResult () } }","title":"III. Effects only in Actor"},{"location":"bestpractices/#iv-feature-to-feature-binding","text":"If one of your Features should always react to when something happens in another, you can use the Bootstrapper for this: class Feature2 ( feature1 : Feature1 ) : ActorReducerFeature < Wish , Effect , State , Nothing >( bootstrapper = BootstrapperImpl ( feature1 ), // remainder omitted ) { class BootstrapperImpl ( private val feature1 : Feature1 ) : Bootstrapper < Wish > { override fun invoke (): Observable < Wish > = feature1 . news . map { SomeWishOfFeature2 } } // remainder omitted This assumes that Feature1 lives longer than Feature2 . If this is not the case, you could still connect them with Binder . bind () .","title":"IV. Feature to Feature binding"},{"location":"demoproject/","text":"Example app \u00b6 You can check out the mvicore - demo - app module and deploy it to your Android device to see some of the possibilities of MVICore applied in practice. Points of interest: Feature1 : Simple state machine holding on to state of coloured buttons and counter Feature2 : Asynchronous state machine responsible for loading images from the The Cat API MainActivityBindings : Showcasing Binder usage, combining the state of Feature1 + Feature2 and translating them to a ViewModel to the screen, also connecting the UI to the Features App . kt for Middleware configurations Dagger configuration to make Feature1 and Feature2 live longer than the Activity, but lose their state on \"sign out / sign in\" cycle Check out the DebugDrawer module (swipeable from the right side of the screen) for Time Travel Debugger controls.","title":"Example app"},{"location":"demoproject/#example-app","text":"You can check out the mvicore - demo - app module and deploy it to your Android device to see some of the possibilities of MVICore applied in practice. Points of interest: Feature1 : Simple state machine holding on to state of coloured buttons and counter Feature2 : Asynchronous state machine responsible for loading images from the The Cat API MainActivityBindings : Showcasing Binder usage, combining the state of Feature1 + Feature2 and translating them to a ViewModel to the screen, also connecting the UI to the Features App . kt for Middleware configurations Dagger configuration to make Feature1 and Feature2 live longer than the Activity, but lose their state on \"sign out / sign in\" cycle Check out the DebugDrawer module (swipeable from the right side of the screen) for Time Travel Debugger controls.","title":"Example app"},{"location":"binder/android/","text":"Lifecycle handling on Android \u00b6 Using AndroidBinderLifecycle directly \u00b6 You can use AndroidBinderLifecycle with any LifecycleOwner to automatically end Binder lifecycle upon onDestroy () override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) val binder = Binder ( AndroidBinderLifecycle ( this . lifecycle )) binder . bind ( a to b ) binder . bind ( c to d ) } Using AndroidBindings \u00b6 Better yet, don't put your bindings into your Activity . Rather, take a look at AndroidBindings , which creates you a Binder automatically: abstract class AndroidBindings < T : Any >( lifecycleOwner : LifecycleOwner ) { protected val binder = Binder ( lifecycle = AndroidBinderLifecycle ( androidLifecycle = lifecycleOwner . lifecycle ) ) abstract fun setup ( view : T ) } By extending this class, you can forget about Binder lifecycle and also extract the concern of creating your bindings: // probably construct this using the DI framework of your choice: class MyActivityBindings ( lifecycleOwner : LifecycleOwner , private val feature : Feature , private val viewModelTransformer : ViewModelTransformer , private val uiEventTransformer : UiEventTransformer , private val analyticsTracker : AnalyticsTracker ) : AndroidBindings < MyActivity >( lifecycleOwner ) { override fun setup ( view : MyActivity ) { binder . bind ( feature to view using viewModelTransformer ) binder . bind ( view to feature using uiEventTransformer ) binder . bind ( view to analyticsTracker ) } } Just inject it to your Activity and call setup : class MyActivity : AppCompatActivity (), ObservableSource < UiEvent >, Consumer < ViewModel > { @Inject lateinit var bindings : MyActivityBindings override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) // TODO inject bindings . setup ( this ) } }","title":"Lifecycle handling on Android"},{"location":"binder/android/#lifecycle-handling-on-android","text":"","title":"Lifecycle handling on Android"},{"location":"binder/android/#using-androidbinderlifecycle-directly","text":"You can use AndroidBinderLifecycle with any LifecycleOwner to automatically end Binder lifecycle upon onDestroy () override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) val binder = Binder ( AndroidBinderLifecycle ( this . lifecycle )) binder . bind ( a to b ) binder . bind ( c to d ) }","title":"Using AndroidBinderLifecycle directly"},{"location":"binder/android/#using-androidbindings","text":"Better yet, don't put your bindings into your Activity . Rather, take a look at AndroidBindings , which creates you a Binder automatically: abstract class AndroidBindings < T : Any >( lifecycleOwner : LifecycleOwner ) { protected val binder = Binder ( lifecycle = AndroidBinderLifecycle ( androidLifecycle = lifecycleOwner . lifecycle ) ) abstract fun setup ( view : T ) } By extending this class, you can forget about Binder lifecycle and also extract the concern of creating your bindings: // probably construct this using the DI framework of your choice: class MyActivityBindings ( lifecycleOwner : LifecycleOwner , private val feature : Feature , private val viewModelTransformer : ViewModelTransformer , private val uiEventTransformer : UiEventTransformer , private val analyticsTracker : AnalyticsTracker ) : AndroidBindings < MyActivity >( lifecycleOwner ) { override fun setup ( view : MyActivity ) { binder . bind ( feature to view using viewModelTransformer ) binder . bind ( view to feature using uiEventTransformer ) binder . bind ( view to analyticsTracker ) } } Just inject it to your Activity and call setup : class MyActivity : AppCompatActivity (), ObservableSource < UiEvent >, Consumer < ViewModel > { @Inject lateinit var bindings : MyActivityBindings override fun onCreate ( savedInstanceState : Bundle ?) { super . onCreate ( savedInstanceState ) // TODO inject bindings . setup ( this ) } }","title":"Using AndroidBindings"},{"location":"binder/binder/","text":"Binder usage and lifecycle \u00b6 What is the Binder and why is it good for me? \u00b6 If you wrote your first Feature , now you may wonder how to start using it. Do you subscribe to its state directly? Do you call .accept ( wish ) on it manually? Well, you can, but there are better ways to do that, which also come with some bonuses. Remember when in the Core concepts we said that Feature is a Consumer of Wish and an ObservableSource of State ? And that in general, the framework is working with outputs of type ObservableSource < T > and inputs of type Consumer < T > ? The Binder is a tool that can: automatically connect those outputs to those inputs by a subscription using a super simple syntax dispose of this subscription when its lifecycle expires automatically add Middlewares around all inputs (logging and time travel debugging, or your custom one) Binder creation \u00b6 Creating an instance is as simple as: val binder = Binder () with manual disposal, or val binder = Binder ( lifecycle ) for automatic disposal of the created bindings when lifecycle expires (more on that below). Binding reactive endpoints \u00b6 You can connect outputs and inputs directly if they are of the same type: val output : ObservableSource < A > = TODO () val input : Consumer < A > = TODO () binder . bind ( output to input ) Or using a transformer if they are of different types: val output : ObservableSource < A > = TODO () val input : Consumer < B > = TODO () val transformer : ( A ) -> B = TODO () binder . bind ( output to input using transformer ) And you can optionally give names to any of those connections: binder . bind ( input to output named \"MyConnection\" ) // or binder . bind ( input to output using transformer named \"MyConnection\" ) Naming a connection signals that it's important to you. This will make more sense later when we'll add Middlewares : You'll see connections with their respective names in the time-travel debug menu You'll see connection names in logs if you use LoggingMiddleware You can opt to dynamically add Middlewares only to named connections (if that's what you want) Lifecycle handling \u00b6 Since all connections created by the Binder are rx subscriptions under the hood, disposing needs to be taken care of. At the simplest: val binder = Binder () // bind stuff binder . bind ( a to b ) binder . bind ( c to d ) // don't forget to call later binder . dispose () But you don't need to do this manually. Binder can take an instance of Lifecycle in its constructor, which is really only a way to signal termination: interface Lifecycle : ObservableSource < Lifecycle . Event > { enum class Event { BEGIN , // currently not used END // signals termination } } A Lifecycle instance can be created by mapping any other observable stream: val stream : Observable < T > = TODO () val lifecycle = Lifecycle . wrap ( stream . map { Lifecycle . Event . END }) Or if you are on Android and using the mvicore - android dependency, you can leverage the AndroidBinderLifecycle class to automatically create Binder lifecycle from Android lifecycle: val lifecycle = AndroidBinderLifecycle ( activity ) // or any other Android LifecycleOwner In both the above cases you don't need to worry about disposing: whenever Lifecycle signals it, the Binder instance will dispose of the created subscriptions: val binder = Binder ( lifecycle ) // bind stuff binder . bind ( a to b ) binder . bind ( c to d ) // no need to dispose manually, will be handled automatically","title":"Binder usage and lifecycle"},{"location":"binder/binder/#binder-usage-and-lifecycle","text":"","title":"Binder usage and lifecycle"},{"location":"binder/binder/#what-is-the-binder-and-why-is-it-good-for-me","text":"If you wrote your first Feature , now you may wonder how to start using it. Do you subscribe to its state directly? Do you call .accept ( wish ) on it manually? Well, you can, but there are better ways to do that, which also come with some bonuses. Remember when in the Core concepts we said that Feature is a Consumer of Wish and an ObservableSource of State ? And that in general, the framework is working with outputs of type ObservableSource < T > and inputs of type Consumer < T > ? The Binder is a tool that can: automatically connect those outputs to those inputs by a subscription using a super simple syntax dispose of this subscription when its lifecycle expires automatically add Middlewares around all inputs (logging and time travel debugging, or your custom one)","title":"What is the Binder and why is it good for me?"},{"location":"binder/binder/#binder-creation","text":"Creating an instance is as simple as: val binder = Binder () with manual disposal, or val binder = Binder ( lifecycle ) for automatic disposal of the created bindings when lifecycle expires (more on that below).","title":"Binder creation"},{"location":"binder/binder/#binding-reactive-endpoints","text":"You can connect outputs and inputs directly if they are of the same type: val output : ObservableSource < A > = TODO () val input : Consumer < A > = TODO () binder . bind ( output to input ) Or using a transformer if they are of different types: val output : ObservableSource < A > = TODO () val input : Consumer < B > = TODO () val transformer : ( A ) -> B = TODO () binder . bind ( output to input using transformer ) And you can optionally give names to any of those connections: binder . bind ( input to output named \"MyConnection\" ) // or binder . bind ( input to output using transformer named \"MyConnection\" ) Naming a connection signals that it's important to you. This will make more sense later when we'll add Middlewares : You'll see connections with their respective names in the time-travel debug menu You'll see connection names in logs if you use LoggingMiddleware You can opt to dynamically add Middlewares only to named connections (if that's what you want)","title":"Binding reactive endpoints"},{"location":"binder/binder/#lifecycle-handling","text":"Since all connections created by the Binder are rx subscriptions under the hood, disposing needs to be taken care of. At the simplest: val binder = Binder () // bind stuff binder . bind ( a to b ) binder . bind ( c to d ) // don't forget to call later binder . dispose () But you don't need to do this manually. Binder can take an instance of Lifecycle in its constructor, which is really only a way to signal termination: interface Lifecycle : ObservableSource < Lifecycle . Event > { enum class Event { BEGIN , // currently not used END // signals termination } } A Lifecycle instance can be created by mapping any other observable stream: val stream : Observable < T > = TODO () val lifecycle = Lifecycle . wrap ( stream . map { Lifecycle . Event . END }) Or if you are on Android and using the mvicore - android dependency, you can leverage the AndroidBinderLifecycle class to automatically create Binder lifecycle from Android lifecycle: val lifecycle = AndroidBinderLifecycle ( activity ) // or any other Android LifecycleOwner In both the above cases you don't need to worry about disposing: whenever Lifecycle signals it, the Binder instance will dispose of the created subscriptions: val binder = Binder ( lifecycle ) // bind stuff binder . bind ( a to b ) binder . bind ( c to d ) // no need to dispose manually, will be handled automatically","title":"Lifecycle handling"},{"location":"binder/binding/","text":"Binding Features to the UI (and other reactive components) \u00b6 I have my Feature, now what? \u00b6 Let's take a step by step approach how to connect our Features to the UI. Let's suppose we have: Feature1 < Wish , State > Binder instance A View, where we want to render the state of Feature1 , and trigger some Wish es on them. Step 1: Direct binding \u00b6 class View : Consumer < Feature1 . State > { val binder : Binder = TODO () val feature : Feature1 = TODO () val button : Button = TODO () val counter : TextView = TODO () val image : ImageView = TODO () val progress : ProgressBar = TODO () fun onCreate () { setupBindings () setupViews () } fun setupBindings () { binder . bind ( feature to this ) } private fun setupViews () { button . setOnClickListener { // directly talking to feature feature . accept ( Feature1 . Wish . Foo ) } } override fun accept ( state : Feature1 . State ) { counter . text = ( state . counter1 + state . counter2 ) % 2 // \"complex logic\" image . url = state . imageUrls . first { it . contains ( \"imgur\" ) } // \"complex logic\" if ( state . isLoading ) progress . visible () else progress . hide () } } In this example, View accepts State directly, and talks to Feature1 directly. This is wrong for multiple reasons: The View is now tightly coupled to Feature1 The View really shouldn't care where it gets the data it wants to display on the screen from. It shouldn't render data models, but rather view models that doesn't require local logic to transform (see the comments about \"complex logic\"). The View has the additional responsibility of managing bindings Let's fix these one by one. Step 2: Extract bindings \u00b6 class Bindings @Inject constructor ( private val feature : Feature1 ) { val binder : Binder = TODO () fun setup ( view : View ) { binder . bind ( feature to view ) } } Now the extra concern is lifted from the View , and it only cares about its input ( State ) and output (triggering Wish ). But let's not stop here. Step 3: Don't render the State, render a ViewModel \u00b6 Define your ViewModel however you see fit. It should contain processed, \"dumb\", simple to display data only, and only what is actually required for your View : data class ViewModel ( val counter : Int , val imageUrl : String , val isLoading : Boolean ) Convert the State to a ViewModel with a ViewModelTransformer : object ViewModelTransformer : ( Feature1 . State ) -> ViewModel { override fun invoke ( state : Feature1 . State ): ViewModel = ViewModel ( // 1. If the State stores data in another / more complex format, // mapping to simple values should be done here, and not in the View // 2. Also the State might contain a lot more stuff, // here we only pass on those actually needed for the View counter = ( state . counter1 + state . counter2 ) % 2 , imageUrl = state . imageUrls . first { it . contains ( \"imgur\" ) }, isLoading = state . isLoading ) } Modify View to consume ViewModel , it becomes much simpler without data model parsing logic: class View : Consumer < ViewModel > { // remainder omitted override fun accept ( vm : ViewModel ) { counter . text = vm . counter image . url = vm . imageUrl if ( state . isLoading ) progress . visible () else progress . hide () } } Modify the Bindings so that it uses the ViewModelTransformer class Bindings @Inject constructor ( private val feature : Feature1 ) { val binder : Binder = TODO () fun setup ( view : View ) { binder . bind ( feature to view using ViewModelTransformer ) } } Now the View doesn't care where it gets its ViewModel from, and can be reused to work with other data sources as well. Step 3: Don't emit Wish, emit a UI Event \u00b6 There's one last thing that's still coupling our View to our Feature1 \u2014 triggering its Wish es directly. Now that the View doesn't know where the ViewModel comes from, why should it talk to Feature1 directly? All it really cares about it is to provide some output. The fact that this can trigger state changes and a new ViewModel to render is secondary from its perspective. Let's define our UI events as: sealed class UiEvent { object ButtonClicked : UiEvent () object ImageClicked : UiEvent () } Let's remove the Feature1 reference from our View , and make it a source of UiEvent s class View ( private val uiEvents : PublishRelay < UiEvent > = PublishRelay . create () ) : Consumer < ViewModel >, ObservableSource < UiEvent > by uiEvents { // remainder omitted private fun setupViews () { button . setOnClickListener { uiEvents . accept ( UiEvent . ButtonClicked ) } image . setOnClickListener { uiEvents . accept ( UiEvent . ImageClicked ) } } } Now we can connect our View to our Feature1 using a transformer, much like how we did with State -> ViewModel , only this time it's in the other direction: object UiEventTransformer : ( UiEvent ) -> Feature1 . Wish ? { override fun invoke ( event : UiEvent ): Feature1 . Wish ? = when ( event ) { is ButtonClicked -> Feature1 . Wish . SetActiveButton ( event . idx ) is PlusClicked -> Feature1 . Wish . IncreaseCounter } } class Bindings @Inject constructor ( private val feature : Feature1 ) { val binder : Binder = TODO () fun setup ( view : View ) { binder . bind ( view to feature using UiEventTransformer ) binder . bind ( feature to view using ViewModelTransformer ) } } Step 4: Profit \u00b6 Let's consider the benefits so far: We completely decoupled our UI and our business logic. Our View doesn't know anything about a Feature , it only knows how to render ViewModels and how to trigger UiEvents , and has become a reusable unit in itself. It can be fed ViewModels from any other source. Bindings, along with their lifecycle, are a separate concern. Additionally, now that we trigger UiEvents in the View , we can bind multiple other components to it in a completely decoupled way! Let's add an analytics tracker: class AnalyticsTracker () : Consumer < UiEvent > { override fun accept ( uiEvent : UiEvent ) { when ( uiEvent ) { is ButtonClicked -> TODO () is PlusClicked -> TODO () } } } And now we can connect it with just one additional line in our Bindings : class Bindings @Inject constructor ( private val feature : Feature1 private val analyticsTracker : AnalyticsTracker ) { val binder : Binder = TODO () fun setup ( view : View ) { binder . bind ( view to analyticsTracker ) binder . bind ( view to feature using UiEventTransformer ) binder . bind ( feature to view using ViewModelTransformer ) } } All this without modifying anything in our View ! Once you add multiple reactive components, the Bindings class becomes your high level overview of the whole graph of who talks to whom, in a really descriptive way.","title":"Binding Features to the UI"},{"location":"binder/binding/#binding-features-to-the-ui-and-other-reactive-components","text":"","title":"Binding Features to the UI (and other reactive components)"},{"location":"binder/binding/#i-have-my-feature-now-what","text":"Let's take a step by step approach how to connect our Features to the UI. Let's suppose we have: Feature1 < Wish , State > Binder instance A View, where we want to render the state of Feature1 , and trigger some Wish es on them.","title":"I have my Feature, now what?"},{"location":"binder/binding/#step-1-direct-binding","text":"class View : Consumer < Feature1 . State > { val binder : Binder = TODO () val feature : Feature1 = TODO () val button : Button = TODO () val counter : TextView = TODO () val image : ImageView = TODO () val progress : ProgressBar = TODO () fun onCreate () { setupBindings () setupViews () } fun setupBindings () { binder . bind ( feature to this ) } private fun setupViews () { button . setOnClickListener { // directly talking to feature feature . accept ( Feature1 . Wish . Foo ) } } override fun accept ( state : Feature1 . State ) { counter . text = ( state . counter1 + state . counter2 ) % 2 // \"complex logic\" image . url = state . imageUrls . first { it . contains ( \"imgur\" ) } // \"complex logic\" if ( state . isLoading ) progress . visible () else progress . hide () } } In this example, View accepts State directly, and talks to Feature1 directly. This is wrong for multiple reasons: The View is now tightly coupled to Feature1 The View really shouldn't care where it gets the data it wants to display on the screen from. It shouldn't render data models, but rather view models that doesn't require local logic to transform (see the comments about \"complex logic\"). The View has the additional responsibility of managing bindings Let's fix these one by one.","title":"Step 1: Direct binding"},{"location":"binder/binding/#step-2-extract-bindings","text":"class Bindings @Inject constructor ( private val feature : Feature1 ) { val binder : Binder = TODO () fun setup ( view : View ) { binder . bind ( feature to view ) } } Now the extra concern is lifted from the View , and it only cares about its input ( State ) and output (triggering Wish ). But let's not stop here.","title":"Step 2: Extract bindings"},{"location":"binder/binding/#step-3-dont-render-the-state-render-a-viewmodel","text":"Define your ViewModel however you see fit. It should contain processed, \"dumb\", simple to display data only, and only what is actually required for your View : data class ViewModel ( val counter : Int , val imageUrl : String , val isLoading : Boolean ) Convert the State to a ViewModel with a ViewModelTransformer : object ViewModelTransformer : ( Feature1 . State ) -> ViewModel { override fun invoke ( state : Feature1 . State ): ViewModel = ViewModel ( // 1. If the State stores data in another / more complex format, // mapping to simple values should be done here, and not in the View // 2. Also the State might contain a lot more stuff, // here we only pass on those actually needed for the View counter = ( state . counter1 + state . counter2 ) % 2 , imageUrl = state . imageUrls . first { it . contains ( \"imgur\" ) }, isLoading = state . isLoading ) } Modify View to consume ViewModel , it becomes much simpler without data model parsing logic: class View : Consumer < ViewModel > { // remainder omitted override fun accept ( vm : ViewModel ) { counter . text = vm . counter image . url = vm . imageUrl if ( state . isLoading ) progress . visible () else progress . hide () } } Modify the Bindings so that it uses the ViewModelTransformer class Bindings @Inject constructor ( private val feature : Feature1 ) { val binder : Binder = TODO () fun setup ( view : View ) { binder . bind ( feature to view using ViewModelTransformer ) } } Now the View doesn't care where it gets its ViewModel from, and can be reused to work with other data sources as well.","title":"Step 3: Don't render the State, render a ViewModel"},{"location":"binder/binding/#step-3-dont-emit-wish-emit-a-ui-event","text":"There's one last thing that's still coupling our View to our Feature1 \u2014 triggering its Wish es directly. Now that the View doesn't know where the ViewModel comes from, why should it talk to Feature1 directly? All it really cares about it is to provide some output. The fact that this can trigger state changes and a new ViewModel to render is secondary from its perspective. Let's define our UI events as: sealed class UiEvent { object ButtonClicked : UiEvent () object ImageClicked : UiEvent () } Let's remove the Feature1 reference from our View , and make it a source of UiEvent s class View ( private val uiEvents : PublishRelay < UiEvent > = PublishRelay . create () ) : Consumer < ViewModel >, ObservableSource < UiEvent > by uiEvents { // remainder omitted private fun setupViews () { button . setOnClickListener { uiEvents . accept ( UiEvent . ButtonClicked ) } image . setOnClickListener { uiEvents . accept ( UiEvent . ImageClicked ) } } } Now we can connect our View to our Feature1 using a transformer, much like how we did with State -> ViewModel , only this time it's in the other direction: object UiEventTransformer : ( UiEvent ) -> Feature1 . Wish ? { override fun invoke ( event : UiEvent ): Feature1 . Wish ? = when ( event ) { is ButtonClicked -> Feature1 . Wish . SetActiveButton ( event . idx ) is PlusClicked -> Feature1 . Wish . IncreaseCounter } } class Bindings @Inject constructor ( private val feature : Feature1 ) { val binder : Binder = TODO () fun setup ( view : View ) { binder . bind ( view to feature using UiEventTransformer ) binder . bind ( feature to view using ViewModelTransformer ) } }","title":"Step 3: Don't emit Wish, emit a UI Event"},{"location":"binder/binding/#step-4-profit","text":"Let's consider the benefits so far: We completely decoupled our UI and our business logic. Our View doesn't know anything about a Feature , it only knows how to render ViewModels and how to trigger UiEvents , and has become a reusable unit in itself. It can be fed ViewModels from any other source. Bindings, along with their lifecycle, are a separate concern. Additionally, now that we trigger UiEvents in the View , we can bind multiple other components to it in a completely decoupled way! Let's add an analytics tracker: class AnalyticsTracker () : Consumer < UiEvent > { override fun accept ( uiEvent : UiEvent ) { when ( uiEvent ) { is ButtonClicked -> TODO () is PlusClicked -> TODO () } } } And now we can connect it with just one additional line in our Bindings : class Bindings @Inject constructor ( private val feature : Feature1 private val analyticsTracker : AnalyticsTracker ) { val binder : Binder = TODO () fun setup ( view : View ) { binder . bind ( view to analyticsTracker ) binder . bind ( view to feature using UiEventTransformer ) binder . bind ( feature to view using ViewModelTransformer ) } } All this without modifying anything in our View ! Once you add multiple reactive components, the Bindings class becomes your high level overview of the whole graph of who talks to whom, in a really descriptive way.","title":"Step 4: Profit"},{"location":"extras/intellijplugin/","text":"IntelliJ plugin to generate Feature templates \u00b6 You can find a plugin for IntelliJ in the repo which contains file templates to default Feature implementations. How to use \u00b6 Download MVICoreFileTemplates.jar Inside the IDE go to \"Install plugin from disk...\" Install the .jar file and restart the IDE In the project tree select any package and pop up the \"New...\" context menu You can filter the options by typing \"feature\" Pick one Enter a name for your new file Profit","title":"IntelliJ plugin"},{"location":"extras/intellijplugin/#intellij-plugin-to-generate-feature-templates","text":"You can find a plugin for IntelliJ in the repo which contains file templates to default Feature implementations.","title":"IntelliJ plugin to generate Feature templates"},{"location":"extras/intellijplugin/#how-to-use","text":"Download MVICoreFileTemplates.jar Inside the IDE go to \"Install plugin from disk...\" Install the .jar file and restart the IDE In the project tree select any package and pop up the \"New...\" context menu You can filter the options by typing \"feature\" Pick one Enter a name for your new file Profit","title":"How to use"},{"location":"extras/ttdui/","text":"Time Travel Debugger UI controls \u00b6 If you are on Android and using DebugDrawer , you can find a UI control module you can add to it in the mvicore - debugdrawer dependency. UI controls include: start recording stop recording start playback record selection dropdown, which automatically updates itself with all records available in the RecordStore","title":"Time Travel Debugger UI controls"},{"location":"extras/ttdui/#time-travel-debugger-ui-controls","text":"If you are on Android and using DebugDrawer , you can find a UI control module you can add to it in the mvicore - debugdrawer dependency. UI controls include: start recording stop recording start playback record selection dropdown, which automatically updates itself with all records available in the RecordStore","title":"Time Travel Debugger UI controls"},{"location":"features/actorreducerfeature/","text":"Handling async jobs \u00b6 Actor \u00b6 If you have anything asynchronous more complex requirements how some Wish will modify the State then now we need to distinguish between incoming Wish an actual Effect that is applied over the State using the Reducer And now we need a mapping between the two. The Actor is basically a function doing just that: typealias Actor < State , Wish , Effect > = ( State , Wish ) -> Observable < out Effect > This means that now we can consider an incoming Wish and our current State , and based on them we can do some operations that will emit Effect s to change our State . Note The operations do not have to be asynchronous. You can still use Observable . just () to return one or more Effect s immediately. The added power here is that you can do that conditionally based on the current State E.g. your Feature represents a form, and then based on the result of form validation over the current state, you can emit different Effect s to signal validation success or error. Important \u00b6 Since invocations of the reducer must always happen on the same thread, you must ensure that you observe results of your asynchronous jobs on that thread. In Android, this practically means calling .observeOn ( AndroidSchedulers.mainThread ()) Excercise #2 \u00b6 Task \u00b6 Let's talk to an async service to load some data Let's signal whether we are in progress of loading, successfully loaded, or if an error has happened Solution using ActorReducerFeature \u00b6 class Feature2 : ActorReducerFeature < Wish , Effect , State , Nothing >( initialState = State (), actor = ActorImpl (), reducer = ReducerImpl () ) { data class State ( val isLoading : Boolean = false , val payload : String ? = null ) sealed class Wish { object LoadNewData : Wish () } sealed class Effect { object StartedLoading : Effect () data class FinishedWithSuccess ( val payload : String ) : Effect () data class FinishedWithError ( val throwable : Throwable ) : Effect () } class ActorImpl : Actor < State , Wish , Effect > { private val service : Observable < String > = TODO () override fun invoke ( state : State , wish : Wish ): Observable < Effect > = when ( wish ) { is LoadNewData -> { if (! state . isLoading ) { service . observeOn ( AndroidSchedulers . mainThread ()) . map { FinishedWithSuccess ( payload = it ) as Effect } . startWith ( StartedLoading ) . onErrorReturn { FinishedWithError ( it ) } } else { Observable . empty () } } } } class ReducerImpl : Reducer < State , Effect > { override fun invoke ( state : State , effect : Effect ): State = when ( effect ) { is StartedLoading -> state . copy ( isLoading = true ) is FinishedWithSuccess -> state . copy ( isLoading = false , payload = effect . payload ) is FinishedWithError -> state . copy ( isLoading = false ) } } } Under the hood, ActorReducerFeature is a subclass of BaseFeature giving you a subset of all the possibilities there. It will also wire everything up for you (reacting to a Wish , calling your Actor and subscribing to the Observable < Effect > returned by it, and calling your Reducer to emit your next State ). Note In this example, the error result is not stored in the state. The preferred way in most cases is an event-based approach seen in the chapter News and inter-feature communication But if you need it, you can still add a field in the State to store the error, just don't forget to reset it in the Reducer upon the next StartedLoading or FinishedWithSuccess effects. Another approach would be to use a Kotlin sealed class, or the functional Either < A , B > type for the payload, where A would be the error, B would be actual data. Really only up to you. When should you use ActorReducerFeature \u00b6 There are async jobs in your Feature There's some extra business logic involving how to react to a Wish conditionally","title":"Handling async jobs"},{"location":"features/actorreducerfeature/#handling-async-jobs","text":"","title":"Handling async jobs"},{"location":"features/actorreducerfeature/#actor","text":"If you have anything asynchronous more complex requirements how some Wish will modify the State then now we need to distinguish between incoming Wish an actual Effect that is applied over the State using the Reducer And now we need a mapping between the two. The Actor is basically a function doing just that: typealias Actor < State , Wish , Effect > = ( State , Wish ) -> Observable < out Effect > This means that now we can consider an incoming Wish and our current State , and based on them we can do some operations that will emit Effect s to change our State . Note The operations do not have to be asynchronous. You can still use Observable . just () to return one or more Effect s immediately. The added power here is that you can do that conditionally based on the current State E.g. your Feature represents a form, and then based on the result of form validation over the current state, you can emit different Effect s to signal validation success or error.","title":"Actor"},{"location":"features/actorreducerfeature/#important","text":"Since invocations of the reducer must always happen on the same thread, you must ensure that you observe results of your asynchronous jobs on that thread. In Android, this practically means calling .observeOn ( AndroidSchedulers.mainThread ())","title":"Important"},{"location":"features/actorreducerfeature/#excercise-2","text":"","title":"Excercise #2"},{"location":"features/actorreducerfeature/#task","text":"Let's talk to an async service to load some data Let's signal whether we are in progress of loading, successfully loaded, or if an error has happened","title":"Task"},{"location":"features/actorreducerfeature/#solution-using-actorreducerfeature","text":"class Feature2 : ActorReducerFeature < Wish , Effect , State , Nothing >( initialState = State (), actor = ActorImpl (), reducer = ReducerImpl () ) { data class State ( val isLoading : Boolean = false , val payload : String ? = null ) sealed class Wish { object LoadNewData : Wish () } sealed class Effect { object StartedLoading : Effect () data class FinishedWithSuccess ( val payload : String ) : Effect () data class FinishedWithError ( val throwable : Throwable ) : Effect () } class ActorImpl : Actor < State , Wish , Effect > { private val service : Observable < String > = TODO () override fun invoke ( state : State , wish : Wish ): Observable < Effect > = when ( wish ) { is LoadNewData -> { if (! state . isLoading ) { service . observeOn ( AndroidSchedulers . mainThread ()) . map { FinishedWithSuccess ( payload = it ) as Effect } . startWith ( StartedLoading ) . onErrorReturn { FinishedWithError ( it ) } } else { Observable . empty () } } } } class ReducerImpl : Reducer < State , Effect > { override fun invoke ( state : State , effect : Effect ): State = when ( effect ) { is StartedLoading -> state . copy ( isLoading = true ) is FinishedWithSuccess -> state . copy ( isLoading = false , payload = effect . payload ) is FinishedWithError -> state . copy ( isLoading = false ) } } } Under the hood, ActorReducerFeature is a subclass of BaseFeature giving you a subset of all the possibilities there. It will also wire everything up for you (reacting to a Wish , calling your Actor and subscribing to the Observable < Effect > returned by it, and calling your Reducer to emit your next State ). Note In this example, the error result is not stored in the state. The preferred way in most cases is an event-based approach seen in the chapter News and inter-feature communication But if you need it, you can still add a field in the State to store the error, just don't forget to reset it in the Reducer upon the next StartedLoading or FinishedWithSuccess effects. Another approach would be to use a Kotlin sealed class, or the functional Either < A , B > type for the payload, where A would be the error, B would be actual data. Really only up to you.","title":"Solution using ActorReducerFeature"},{"location":"features/actorreducerfeature/#when-should-you-use-actorreducerfeature","text":"There are async jobs in your Feature There's some extra business logic involving how to react to a Wish conditionally","title":"When should you use ActorReducerFeature"},{"location":"features/bootstrappers/","text":"Bootstrappers \u00b6 Listening to remote sources \u00b6 So far all of the triggers to our Feature s were internal: Wish es come from client code Action s are triggered inside Feature in the PostProcessor But what if you need to react to let's say when the server sends you a push? You can of course listen to them outside of your Feature and then push Wish es, but this has its own disadvantages: Part of your business logic is now living outside of your class. If you are passing your component around for others to use, everyone will need to pay attention how to set it up. This is not correct. From outside you can only trigger public Wish es, not Action s The Bootstrapper is solving exactly these problems. Bootstrapper \u00b6 It's defined as: typealias Bootstrapper < Action > = () -> Observable < Action > which practically means, that when invoked, it can give you a stream of Action s. You can use this interface to add initial wiring to your Feature : class BootstrapperImpl : Bootstrapper < Action > { private val service1 : Observable < Any > = TODO () private val service2 : Observable < Any > = TODO () override fun invoke (): Observable < Action > = Observable . merge < Action >( service1 . map { InvalidateCache }, service2 . map { ReloadSomething } ). observeOn ( AndroidSchedulers . mainThread ()) } Pass your Bootstrapper implementation in the constructor to either ReducerFeature , ActorReducerFeature , or BaseFeature : class MyComplexFeature : BaseFeature < Wish , Action , Effect , State , News >( // ...remainder omitted... bootstrapper = BootstrapperImpl () ) The implementation of BaseFeature wires it up for you.","title":"Bootstrappers"},{"location":"features/bootstrappers/#bootstrappers","text":"","title":"Bootstrappers"},{"location":"features/bootstrappers/#listening-to-remote-sources","text":"So far all of the triggers to our Feature s were internal: Wish es come from client code Action s are triggered inside Feature in the PostProcessor But what if you need to react to let's say when the server sends you a push? You can of course listen to them outside of your Feature and then push Wish es, but this has its own disadvantages: Part of your business logic is now living outside of your class. If you are passing your component around for others to use, everyone will need to pay attention how to set it up. This is not correct. From outside you can only trigger public Wish es, not Action s The Bootstrapper is solving exactly these problems.","title":"Listening to remote sources"},{"location":"features/bootstrappers/#bootstrapper","text":"It's defined as: typealias Bootstrapper < Action > = () -> Observable < Action > which practically means, that when invoked, it can give you a stream of Action s. You can use this interface to add initial wiring to your Feature : class BootstrapperImpl : Bootstrapper < Action > { private val service1 : Observable < Any > = TODO () private val service2 : Observable < Any > = TODO () override fun invoke (): Observable < Action > = Observable . merge < Action >( service1 . map { InvalidateCache }, service2 . map { ReloadSomething } ). observeOn ( AndroidSchedulers . mainThread ()) } Pass your Bootstrapper implementation in the constructor to either ReducerFeature , ActorReducerFeature , or BaseFeature : class MyComplexFeature : BaseFeature < Wish , Action , Effect , State , News >( // ...remainder omitted... bootstrapper = BootstrapperImpl () ) The implementation of BaseFeature wires it up for you.","title":"Bootstrapper"},{"location":"features/coreconcepts/","text":"Core concepts \u00b6 Sources and consumers \u00b6 MVICore works with sources and consumers of observable data at its heart. That is: outputs are of type ObservableSource < T > inputs are of type Consumer < T > Stores \u00b6 The Store < Wish , State > interface defines the outline of a state machine that - can receive objects of type Wish on its input - can produce objects of type State on its output - in addition, it holds on to the latest State , which can be queried without subscribing to the Store interface Store < Wish : Any , State : Any > : Consumer < Wish >, ObservableSource < State > { val state : State } State is meant to be immutable, for which we'll use Kotlin data classes. Features \u00b6 A Feature is really only a Store with the addition of: being Disposable , as it might hold subscriptions being a source of News interface Feature < Wish : Any , State : Any , News : Any > : Store < Wish , State >, Disposable { val news : ObservableSource < News > } News marks the type of the events a Feature can emit. These are pieces of information you don\u2019t want to store in the state, just fire off once when they happen. More about that in the chapter News and inter-feature communication . Feature lifecycle \u00b6 Most probably you want your Feature to live longer than the current screen. This has many benefits: You don't need to override onSaveInstanceState and onRestoreInstanceState in your Android Activity . The Feature holds on to the state, the Activity connects to it in its onCreate method, and because the stream of State s inside is a BehaviorSubject , it will replay the latest one to your Activity upon subscription. Rotating the screen? Not an issue, your state is automatically there. Your Feature is not on screen because the user navigated away to some other screen? Not a problem. It's still alive and listening in the background to update its state if needed, so when the user comes back to the screen where it's visible, it immediately shows the most up-to-date state. This probably implies that your Feature is living in some kind of a DI scope, and it's your responsibility to call .dispose () on it once this scope goes away, so that any asynchronous jobs still executing are properly disposed of. Bottom line Don't forget to call .dispose () at the end of the Feature 's lifecycle","title":"Core concepts"},{"location":"features/coreconcepts/#core-concepts","text":"","title":"Core concepts"},{"location":"features/coreconcepts/#sources-and-consumers","text":"MVICore works with sources and consumers of observable data at its heart. That is: outputs are of type ObservableSource < T > inputs are of type Consumer < T >","title":"Sources and consumers"},{"location":"features/coreconcepts/#stores","text":"The Store < Wish , State > interface defines the outline of a state machine that - can receive objects of type Wish on its input - can produce objects of type State on its output - in addition, it holds on to the latest State , which can be queried without subscribing to the Store interface Store < Wish : Any , State : Any > : Consumer < Wish >, ObservableSource < State > { val state : State } State is meant to be immutable, for which we'll use Kotlin data classes.","title":"Stores"},{"location":"features/coreconcepts/#features","text":"A Feature is really only a Store with the addition of: being Disposable , as it might hold subscriptions being a source of News interface Feature < Wish : Any , State : Any , News : Any > : Store < Wish , State >, Disposable { val news : ObservableSource < News > } News marks the type of the events a Feature can emit. These are pieces of information you don\u2019t want to store in the state, just fire off once when they happen. More about that in the chapter News and inter-feature communication .","title":"Features"},{"location":"features/coreconcepts/#feature-lifecycle","text":"Most probably you want your Feature to live longer than the current screen. This has many benefits: You don't need to override onSaveInstanceState and onRestoreInstanceState in your Android Activity . The Feature holds on to the state, the Activity connects to it in its onCreate method, and because the stream of State s inside is a BehaviorSubject , it will replay the latest one to your Activity upon subscription. Rotating the screen? Not an issue, your state is automatically there. Your Feature is not on screen because the user navigated away to some other screen? Not a problem. It's still alive and listening in the background to update its state if needed, so when the user comes back to the screen where it's visible, it immediately shows the most up-to-date state. This probably implies that your Feature is living in some kind of a DI scope, and it's your responsibility to call .dispose () on it once this scope goes away, so that any asynchronous jobs still executing are properly disposed of. Bottom line Don't forget to call .dispose () at the end of the Feature 's lifecycle","title":"Feature lifecycle"},{"location":"features/fullfeatured/","text":"Going full-featured \u00b6 BaseFeature \u00b6 If the reduced functionality of ReducerFeature and ActorReducerFeature is not enough for your case, this base class is your go-to. BaseFeature takes four generic parameters: BaseFeature < Wish , Action , Effect , State > The new one here compared to the simpler Features is the Action . Actions \u00b6 Use-case: you need some kind of an \"internal Wish \" to execute, but you don't want to leak it through your Wish sealed class, as it would make it publicly callable. you want to be able to trigger these \"internal Wish es\" Action is a superset of Wish in the form of: sealed class Wish { object PublicWish1 : Wish () object PublicWish2 : Wish () object PublicWish3 : Wish () } sealed class Action { data class Execute ( val wish : Wish ) : Action () object InvalidateCache : Action () object ReloadSomething : Action () } This has two implications: For BaseFeature to know how your public Wish maps to an Action , you need to supply a mapping function in the constructor typealias WishToAction < Wish , Action > = ( Wish ) -> Action Now your Actor will be acting upon Action instead of Wish So any incoming Wish is mapped to an Action , and executed in the Actor along with all other Action s: class MyComplexFeature : BaseFeature < Wish , Action , Effect , State >( // ...remainder omitted... wishToAction = { Execute ( it ) }, actor = ActorImpl (), ) { // ...remainder omitted... sealed class Wish { object PublicWish1 : Wish () object PublicWish2 : Wish () object PublicWish3 : Wish () } sealed class Action { data class Execute ( val wish : Wish ) : Action () object InvalidateCache : Action () object ReloadSomething : Action () } class ActorImpl : Actor < State , Action , Effect > { override fun invoke ( state : State , action : Action ): Observable < Effect > = when ( action ) { is Execute -> when ( action . wish ) { PublicWish1 -> TODO () PublicWish2 -> TODO () PublicWish3 -> TODO () } InvalidateCache -> TODO () ReloadSomething -> TODO () } } // ...remainder omitted... } So now you can have internal Action s, but how will you trigger them? Meet the PostProcessor . PostProcessor \u00b6 The PostProcessor (as the name implies) will have a chance to react after a certain Action was mapped to a certain Effect which was used to create a new State . At this point, it can signal the need for additional Action s: typealias PostProcessor < Action , Effect , State > = ( Action , Effect , State ) -> Action ? Using the example above this could be: class MyComplexFeature : BaseFeature < Wish , Action , Effect , State >( // ...remainder omitted... postProcessor = PostProcessorImpl () ) { // ...remainder omitted... class PostProcessorImpl : PostProcessor < Action , Effect , State > { // do anything based on action (contains wish), effect, state override fun invoke ( action : Action , effect : Effect , state : State ): Action ? { if ( state . i == 101 ) { return InvalidateCache } return null } } } The implementation of BaseFeature wires everything up for you from mapping your Wish to Action , calling your Actor , Reducer , and PostProcessor and emitting the next State .","title":"Going full-featured"},{"location":"features/fullfeatured/#going-full-featured","text":"","title":"Going full-featured"},{"location":"features/fullfeatured/#basefeature","text":"If the reduced functionality of ReducerFeature and ActorReducerFeature is not enough for your case, this base class is your go-to. BaseFeature takes four generic parameters: BaseFeature < Wish , Action , Effect , State > The new one here compared to the simpler Features is the Action .","title":"BaseFeature"},{"location":"features/fullfeatured/#actions","text":"Use-case: you need some kind of an \"internal Wish \" to execute, but you don't want to leak it through your Wish sealed class, as it would make it publicly callable. you want to be able to trigger these \"internal Wish es\" Action is a superset of Wish in the form of: sealed class Wish { object PublicWish1 : Wish () object PublicWish2 : Wish () object PublicWish3 : Wish () } sealed class Action { data class Execute ( val wish : Wish ) : Action () object InvalidateCache : Action () object ReloadSomething : Action () } This has two implications: For BaseFeature to know how your public Wish maps to an Action , you need to supply a mapping function in the constructor typealias WishToAction < Wish , Action > = ( Wish ) -> Action Now your Actor will be acting upon Action instead of Wish So any incoming Wish is mapped to an Action , and executed in the Actor along with all other Action s: class MyComplexFeature : BaseFeature < Wish , Action , Effect , State >( // ...remainder omitted... wishToAction = { Execute ( it ) }, actor = ActorImpl (), ) { // ...remainder omitted... sealed class Wish { object PublicWish1 : Wish () object PublicWish2 : Wish () object PublicWish3 : Wish () } sealed class Action { data class Execute ( val wish : Wish ) : Action () object InvalidateCache : Action () object ReloadSomething : Action () } class ActorImpl : Actor < State , Action , Effect > { override fun invoke ( state : State , action : Action ): Observable < Effect > = when ( action ) { is Execute -> when ( action . wish ) { PublicWish1 -> TODO () PublicWish2 -> TODO () PublicWish3 -> TODO () } InvalidateCache -> TODO () ReloadSomething -> TODO () } } // ...remainder omitted... } So now you can have internal Action s, but how will you trigger them? Meet the PostProcessor .","title":"Actions"},{"location":"features/fullfeatured/#postprocessor","text":"The PostProcessor (as the name implies) will have a chance to react after a certain Action was mapped to a certain Effect which was used to create a new State . At this point, it can signal the need for additional Action s: typealias PostProcessor < Action , Effect , State > = ( Action , Effect , State ) -> Action ? Using the example above this could be: class MyComplexFeature : BaseFeature < Wish , Action , Effect , State >( // ...remainder omitted... postProcessor = PostProcessorImpl () ) { // ...remainder omitted... class PostProcessorImpl : PostProcessor < Action , Effect , State > { // do anything based on action (contains wish), effect, state override fun invoke ( action : Action , effect : Effect , state : State ): Action ? { if ( state . i == 101 ) { return InvalidateCache } return null } } } The implementation of BaseFeature wires everything up for you from mapping your Wish to Action , calling your Actor , Reducer , and PostProcessor and emitting the next State .","title":"PostProcessor"},{"location":"features/news/","text":"News and inter-feature communication \u00b6 News \u00b6 As we\u2019ve seen, the Feature interface has a third generic type of News : interface Feature < Wish : Any , State : Any , News : Any > : Store < Wish , State >, Disposable { val news : ObservableSource < News > } News is the type that a Feature can use for signaling single events. This is to address a recurring issue with MVI approaches: how do you handle events that should be consumed only once? For example, a toast / snackbar message, or a redirect event. If you store this information in the state, then it will remain there until you clear it - and until that is done, all subsequent subscribers to that state will receive it again. Sometimes that\u2019s just what you want, but it\u2019s also a valid case, that showing those messages later again makes no sense (if they are outdated and irrelevant now), or that going back to a screen which still holds a redirect order in its state will cause you problems. The approach in this library is to create a separation between states and events, and not store the latter in the previous in any form. Rather, all Feature implementations can have their very own NewsPublisher : typealias NewsPublisher < Action , Effect , State , News > = ( Action , Effect , State ) -> News ? Its invocation has access to all the parameters of the current execution chain (which action triggered which effect, which resulted in what new state), and by implementing it you can fabricate any condition based on those to signal emitting News . You can pass a NewsPublisher implementation in your constructor to the base classes, and the framework will make sure to call it after each new state emission. Any News produced by it will then be observable through the news property of the feature automatically: class FeatureImpl : ActorReducerFeature < Wish , Effect , State , News >( // ...remainder omitted... newsPublisher = NewsPublisherImpl () ) { // ...remainder omitted... sealed class Effect { // ...remainder omitted... data class ErrorLoading ( val throwable : Throwable ) : Effect () } sealed class News { data class ErrorExecutingRequest ( val throwable : Throwable ) : News () } class NewsPublisherImpl : NewsPublisher < Wish , Effect , State , News > { override fun invoke ( wish : Wish , effect : Effect , state : State ): News ? = when ( effect ) { is ErrorLoading -> News . ErrorExecutingRequest ( effect . throwable ) else -> null } } } Then somewhere else with an instance of this class you can observe the News and react to them: val featureImpl : FeatureImpl = TODO () // inject or create val news : ObservableSource < FeatureImpl . News > = featureImpl . news // subscribe to news or bind it to a Consumer<FeatureImpl.News>: fun accept ( news : FeatureImpl . News ) { when ( featureImpl . news ) { is News . ErrorExecutingRequest -> doSomethingWith ( news . throwable ) } } fun doSomethingWith ( throwable : Throwable ) { // log it // show toast // etc. } So how is this beneficial to you? To sum it up, using this approach allows you to: React on single events which would be probably inconvenient to store in the State React to what happened rather than how it changed the state Inter-feature communication by mapping an important event from one feature to a wish of another (you could inject an instance of Feature1 to Feature2 , which could use Feature1 . news as a source in its Bootstrapper to automatically react)","title":"News and inter-feature communication"},{"location":"features/news/#news-and-inter-feature-communication","text":"","title":"News and inter-feature communication"},{"location":"features/news/#news","text":"As we\u2019ve seen, the Feature interface has a third generic type of News : interface Feature < Wish : Any , State : Any , News : Any > : Store < Wish , State >, Disposable { val news : ObservableSource < News > } News is the type that a Feature can use for signaling single events. This is to address a recurring issue with MVI approaches: how do you handle events that should be consumed only once? For example, a toast / snackbar message, or a redirect event. If you store this information in the state, then it will remain there until you clear it - and until that is done, all subsequent subscribers to that state will receive it again. Sometimes that\u2019s just what you want, but it\u2019s also a valid case, that showing those messages later again makes no sense (if they are outdated and irrelevant now), or that going back to a screen which still holds a redirect order in its state will cause you problems. The approach in this library is to create a separation between states and events, and not store the latter in the previous in any form. Rather, all Feature implementations can have their very own NewsPublisher : typealias NewsPublisher < Action , Effect , State , News > = ( Action , Effect , State ) -> News ? Its invocation has access to all the parameters of the current execution chain (which action triggered which effect, which resulted in what new state), and by implementing it you can fabricate any condition based on those to signal emitting News . You can pass a NewsPublisher implementation in your constructor to the base classes, and the framework will make sure to call it after each new state emission. Any News produced by it will then be observable through the news property of the feature automatically: class FeatureImpl : ActorReducerFeature < Wish , Effect , State , News >( // ...remainder omitted... newsPublisher = NewsPublisherImpl () ) { // ...remainder omitted... sealed class Effect { // ...remainder omitted... data class ErrorLoading ( val throwable : Throwable ) : Effect () } sealed class News { data class ErrorExecutingRequest ( val throwable : Throwable ) : News () } class NewsPublisherImpl : NewsPublisher < Wish , Effect , State , News > { override fun invoke ( wish : Wish , effect : Effect , state : State ): News ? = when ( effect ) { is ErrorLoading -> News . ErrorExecutingRequest ( effect . throwable ) else -> null } } } Then somewhere else with an instance of this class you can observe the News and react to them: val featureImpl : FeatureImpl = TODO () // inject or create val news : ObservableSource < FeatureImpl . News > = featureImpl . news // subscribe to news or bind it to a Consumer<FeatureImpl.News>: fun accept ( news : FeatureImpl . News ) { when ( featureImpl . news ) { is News . ErrorExecutingRequest -> doSomethingWith ( news . throwable ) } } fun doSomethingWith ( throwable : Throwable ) { // log it // show toast // etc. } So how is this beneficial to you? To sum it up, using this approach allows you to: React on single events which would be probably inconvenient to store in the State React to what happened rather than how it changed the state Inter-feature communication by mapping an important event from one feature to a wish of another (you could inject an instance of Feature1 to Feature2 , which could use Feature1 . news as a source in its Bootstrapper to automatically react)","title":"News"},{"location":"features/reducerfeature/","text":"Your first and simplest feature \u00b6 Reducer \u00b6 Your simplest Feature would be one which only uses a Reducer to create and emit new states based on the latest one and an incoming effect. The Reducer is basically a function defining just that: typealias Reducer < State , Effect > = ( State , Effect ) -> State The name Effect is used here in the more generic context. Note Later there will be a distinction between Wish es and Effect s, but for now, they are one and the same in this simplest example. Important \u00b6 Invocations of the reducer must always happen on the same thread to ensure that new Effect s are always applied to the latest State and we are not losing modifications. If two threads were to read State n , then apply some Effect over it, one would derive State n+1' , while the other would derive State n+1'' from it, and depending on the order of execution, one or the other would be lost. By enforcing the single-thread policy, all Effect s are always applied to the latest state. Excercise #1 \u00b6 Task \u00b6 Let's store a counter in our state Let's make it possible to increment this counter by a Wish Solution using ReducerFeature \u00b6 Meet the simplest Feature , the ReducerFeature : class Feature1 : ReducerFeature < Wish , State , Nothing >( initialState = State (), reducer = ReducerImpl () ) { data class State ( val counter : Int = 0 ) sealed class Wish { object IncrementCounter : Wish () } class ReducerImpl : Reducer < State , Wish > { override fun invoke ( state : State , wish : Wish ): State = when ( wish ) { IncrementCounter -> state . copy ( counter = state . counter + 1 ) } } } Under the hood, ReducerFeature is a subclass of BaseFeature giving you a subset of all the possibilities there. It will also wire everything up for you (reacting to a Wish , calling your Reducer , emitting your next State ). When should you use ReducerFeature \u00b6 There are no async jobs in your Feature There's no extra business logic. Whatever comes in as a Wish , always modifies the State without a question, and we just want to keep track of it.","title":"Your first and simplest feature"},{"location":"features/reducerfeature/#your-first-and-simplest-feature","text":"","title":"Your first and simplest feature"},{"location":"features/reducerfeature/#reducer","text":"Your simplest Feature would be one which only uses a Reducer to create and emit new states based on the latest one and an incoming effect. The Reducer is basically a function defining just that: typealias Reducer < State , Effect > = ( State , Effect ) -> State The name Effect is used here in the more generic context. Note Later there will be a distinction between Wish es and Effect s, but for now, they are one and the same in this simplest example.","title":"Reducer"},{"location":"features/reducerfeature/#important","text":"Invocations of the reducer must always happen on the same thread to ensure that new Effect s are always applied to the latest State and we are not losing modifications. If two threads were to read State n , then apply some Effect over it, one would derive State n+1' , while the other would derive State n+1'' from it, and depending on the order of execution, one or the other would be lost. By enforcing the single-thread policy, all Effect s are always applied to the latest state.","title":"Important"},{"location":"features/reducerfeature/#excercise-1","text":"","title":"Excercise #1"},{"location":"features/reducerfeature/#task","text":"Let's store a counter in our state Let's make it possible to increment this counter by a Wish","title":"Task"},{"location":"features/reducerfeature/#solution-using-reducerfeature","text":"Meet the simplest Feature , the ReducerFeature : class Feature1 : ReducerFeature < Wish , State , Nothing >( initialState = State (), reducer = ReducerImpl () ) { data class State ( val counter : Int = 0 ) sealed class Wish { object IncrementCounter : Wish () } class ReducerImpl : Reducer < State , Wish > { override fun invoke ( state : State , wish : Wish ): State = when ( wish ) { IncrementCounter -> state . copy ( counter = state . counter + 1 ) } } } Under the hood, ReducerFeature is a subclass of BaseFeature giving you a subset of all the possibilities there. It will also wire everything up for you (reacting to a Wish , calling your Reducer , emitting your next State ).","title":"Solution using ReducerFeature"},{"location":"features/reducerfeature/#when-should-you-use-reducerfeature","text":"There are no async jobs in your Feature There's no extra business logic. Whatever comes in as a Wish , always modifies the State without a question, and we just want to keep track of it.","title":"When should you use ReducerFeature"},{"location":"middlewares/configuration/","text":"Middleware configurations \u00b6 What is a Middleware configuration? \u00b6 It is defined as a pair of a condition and a list of factories: data class MiddlewareConfiguration ( private val condition : WrappingCondition , private val factories : List < ConsumerMiddlewareFactory <*>> ) If the WrappingCondition returns true , all the Middlewares created by factories will be wrapped around the target. If it returns false , the original object is returned without any modifications. What is a WrappingCondition? \u00b6 WrappingCondition is an interface with the sole responsibility of deciding whether any target should be wrapped or not: interface WrappingCondition { fun shouldWrap ( target : Any , name : String ?, standalone : Boolean ) : Boolean } The interface contains implementations for most common case checks, such as: // Implementations checking the target -- returns true if the target: WrappingCondition . IsNamed // ...has a name WrappingCondition . Name . SimpleMatcher // ...has a name that contains a given substring WrappingCondition . Name . Regex // ...has a name that matches a given regex WrappingCondition . InstanceOf // ...is an instance of a given class / interface WrappingCondition . PackageName . SimpleMatcher // ...has a package name that contains a given substring WrappingCondition . PackageName . Regex // ...has a package name that matches a given regex WrappingCondition . IsStandalone // ...is standalone (not part of a binding) // Implementations checking a condition -- returns true: WrappingCondition . Always // ...always WrappingCondition . Never // ...never WrappingCondition . Conditional // ...if a given () -> Boolean lambda returns true // Implementations delegating to others -- returns true if: WrappingCondition . Not // the passed WrappingCondition returns false WrappingCondition . EitherOr // delegates to one of two given WrappingConditions based on a condition WrappingCondition . AnyOf // any of the passed WrappingConditions return true WrappingCondition . AllOf // all of the passed WrappingConditions return true If the above is not enough for any reason, you can write your own implementation of the interface. What is a ConsumerMiddlewareFactory? \u00b6 Basically just a lambda to create a Middleware given a Consumer < T > : typealias ConsumerMiddlewareFactory < T > = ( Consumer < T >) -> ConsumerMiddleware < T > // In practice: val middlewareFactory : ConsumerMiddlewareFactory <*> = { consumer -> SomeMiddleware ( consumer ) } Ok, how do I use it? \u00b6 Let's say: You want to add LoggingMiddleware to all of your bindings and consumers and You only want to add PlaybackMiddleware to bindings and consumers if all of these hold true: it's a debug build they are named they are in a certain package but they are definitely not an instance of some class Here's how you would do it: Middlewares . configurations . add ( MiddlewareConfiguration ( condition = WrappingCondition . Always , factories = listOf ( { consumer -> LoggingMiddleware ( consumer , { Timber . d ( it ) }) } ) ) ) Middlewares . configurations . add ( MiddlewareConfiguration ( condition = WrappingCondition . AllOf ( WrappingCondition . Conditional { BuildConfig . DEBUG }, WrappingCondition . IsNamed , WrappingCondition . PackageName . SimpleMatcher ( \"com.example.package\" ), WrappingCondition . Not ( WrappingCondition . InstanceOf ( SomeClass :: class . java ) ) ), factories = listOf ( { consumer -> PlaybackMiddleware ( consumer , recordStore , { Timber . d ( it ) }) } ) ) ) Under the hood \u00b6 Whenever you call .wrap a Consumer < T > manually, or whenever the Binder does the same automatically, the extension function will apply your list of MiddlewareConfiguration objects: fun < T : Any > Consumer < T >. wrap ( name : String ? = null , // remainder omitted ): Consumer < T > { // remainder omitted Middlewares . configurations . forEach { current = it . applyOn ( current , target , name , standalone ) } // remainder omitted return current }","title":"Middleware configurations"},{"location":"middlewares/configuration/#middleware-configurations","text":"","title":"Middleware configurations"},{"location":"middlewares/configuration/#what-is-a-middleware-configuration","text":"It is defined as a pair of a condition and a list of factories: data class MiddlewareConfiguration ( private val condition : WrappingCondition , private val factories : List < ConsumerMiddlewareFactory <*>> ) If the WrappingCondition returns true , all the Middlewares created by factories will be wrapped around the target. If it returns false , the original object is returned without any modifications.","title":"What is a Middleware configuration?"},{"location":"middlewares/configuration/#what-is-a-wrappingcondition","text":"WrappingCondition is an interface with the sole responsibility of deciding whether any target should be wrapped or not: interface WrappingCondition { fun shouldWrap ( target : Any , name : String ?, standalone : Boolean ) : Boolean } The interface contains implementations for most common case checks, such as: // Implementations checking the target -- returns true if the target: WrappingCondition . IsNamed // ...has a name WrappingCondition . Name . SimpleMatcher // ...has a name that contains a given substring WrappingCondition . Name . Regex // ...has a name that matches a given regex WrappingCondition . InstanceOf // ...is an instance of a given class / interface WrappingCondition . PackageName . SimpleMatcher // ...has a package name that contains a given substring WrappingCondition . PackageName . Regex // ...has a package name that matches a given regex WrappingCondition . IsStandalone // ...is standalone (not part of a binding) // Implementations checking a condition -- returns true: WrappingCondition . Always // ...always WrappingCondition . Never // ...never WrappingCondition . Conditional // ...if a given () -> Boolean lambda returns true // Implementations delegating to others -- returns true if: WrappingCondition . Not // the passed WrappingCondition returns false WrappingCondition . EitherOr // delegates to one of two given WrappingConditions based on a condition WrappingCondition . AnyOf // any of the passed WrappingConditions return true WrappingCondition . AllOf // all of the passed WrappingConditions return true If the above is not enough for any reason, you can write your own implementation of the interface.","title":"What is a WrappingCondition?"},{"location":"middlewares/configuration/#what-is-a-consumermiddlewarefactory","text":"Basically just a lambda to create a Middleware given a Consumer < T > : typealias ConsumerMiddlewareFactory < T > = ( Consumer < T >) -> ConsumerMiddleware < T > // In practice: val middlewareFactory : ConsumerMiddlewareFactory <*> = { consumer -> SomeMiddleware ( consumer ) }","title":"What is a ConsumerMiddlewareFactory?"},{"location":"middlewares/configuration/#ok-how-do-i-use-it","text":"Let's say: You want to add LoggingMiddleware to all of your bindings and consumers and You only want to add PlaybackMiddleware to bindings and consumers if all of these hold true: it's a debug build they are named they are in a certain package but they are definitely not an instance of some class Here's how you would do it: Middlewares . configurations . add ( MiddlewareConfiguration ( condition = WrappingCondition . Always , factories = listOf ( { consumer -> LoggingMiddleware ( consumer , { Timber . d ( it ) }) } ) ) ) Middlewares . configurations . add ( MiddlewareConfiguration ( condition = WrappingCondition . AllOf ( WrappingCondition . Conditional { BuildConfig . DEBUG }, WrappingCondition . IsNamed , WrappingCondition . PackageName . SimpleMatcher ( \"com.example.package\" ), WrappingCondition . Not ( WrappingCondition . InstanceOf ( SomeClass :: class . java ) ) ), factories = listOf ( { consumer -> PlaybackMiddleware ( consumer , recordStore , { Timber . d ( it ) }) } ) ) )","title":"Ok, how do I use it?"},{"location":"middlewares/configuration/#under-the-hood","text":"Whenever you call .wrap a Consumer < T > manually, or whenever the Binder does the same automatically, the extension function will apply your list of MiddlewareConfiguration objects: fun < T : Any > Consumer < T >. wrap ( name : String ? = null , // remainder omitted ): Consumer < T > { // remainder omitted Middlewares . configurations . forEach { current = it . applyOn ( current , target , name , standalone ) } // remainder omitted return current }","title":"Under the hood"},{"location":"middlewares/loggingmiddleware/","text":"LoggingMiddleware \u00b6 Logging - out of the box \u00b6 MVICore comes with a configurable LoggingMiddleware that you can use right away. val wrapped = LoggingMiddleware ( consumer , { System . out . println ( it ) }) The actual logging part is not hardcoded, so you can set your preferred way of producing output. The constructor also accepts an optional Configuration object if you want to modify the templates it uses. Check the actual file for more details.","title":"LoggingMiddleware"},{"location":"middlewares/loggingmiddleware/#loggingmiddleware","text":"","title":"LoggingMiddleware"},{"location":"middlewares/loggingmiddleware/#logging-out-of-the-box","text":"MVICore comes with a configurable LoggingMiddleware that you can use right away. val wrapped = LoggingMiddleware ( consumer , { System . out . println ( it ) }) The actual logging part is not hardcoded, so you can set your preferred way of producing output. The constructor also accepts an optional Configuration object if you want to modify the templates it uses. Check the actual file for more details.","title":"Logging - out of the box"},{"location":"middlewares/middleware/","text":"What is a middleware and why is it good for me? \u00b6 TL;DR \u00b6 You can extract the cross-cutting concerns of your app (like logging) and put them into Middlewares that can be used as generic plugins instead of copy-pasting the same solution over and over and polluting your code. The big picture \u00b6 You can picture this like a wrapped input: No middleware: Source -> Input Adding a layer of middleware: Source -> Middleware ( Input ) Adding n layers of middleware: Source -> Middleware ( Middleware (... Middleware ( Input )...)) Every layer of Middleware forwards its input to its wrapped inner core (whether its the actual Input , or just another layer of Middleware ). Whether or not an Input is wrapped in Middlewares is unknown to the Source . The base idea \u00b6 Consider the Consumer < T > interface: package io.reactivex.functions ; /** * A functional interface (callback) that accepts a single value. * @param <T> the value type */ public interface Consumer < T > { /** * Consume the given value. * @param t the value * @throws Exception on error */ void accept ( T t ) throws Exception ; } We can easily create a wrapper layer around it: abstract class Middleware < T >( private val wrapped : Consumer < T > ) : Consumer < T > { override fun accept ( t : T ) { // do whatever you want before passing it to wrapped... wrapped . accept ( t ) // ... or after it // ... or even modify what's passed down to wrapped } } Let's play around with it and add some simple implementations: class HelloMiddleware ( private val wrapped : Consumer < String > ) : Middleware < String >( wrapped ) { override fun accept ( t : String ) { wrapped . accept ( \"Hello $t\" ) } } class ReverserMiddleware ( private val wrapped : Consumer < String > ) : Middleware < String >( wrapped ) { override fun accept ( t : String ) { wrapped . accept ( t . reversed ()) } } class LoggingMiddleware < T >( private val wrapped : Consumer < T >, private val logger : ( String ) -> Unit ) : Middleware < T >( wrapped ) { override fun accept ( t : T ) { logger . invoke ( \"LoggingMiddleware: element - $t\" ) wrapped . accept ( t ) } } Now we can compose them and take them for a test ride: val target : Consumer < String > = TODO () val wrappedWithMiddlewares : Consumer < String > = ReverserMiddleware ( HelloMiddleware ( LoggingMiddleware ( { System . out . println ( it ) }, target ) ) ) wrappedWithMiddlewares . accept ( \"MVICore\" ) // Should output to console: // \"LoggingMiddleware: element - Hello orecIVM!\" Explanation: the order in which an element is passing through the Middleware layers is from the outermost -> inwards. In the above example this means that the passed in string: gets reversed gets decorated with Hello %s! gets logged","title":"What is a middleware?"},{"location":"middlewares/middleware/#what-is-a-middleware-and-why-is-it-good-for-me","text":"","title":"What is a middleware and why is it good for me?"},{"location":"middlewares/middleware/#tldr","text":"You can extract the cross-cutting concerns of your app (like logging) and put them into Middlewares that can be used as generic plugins instead of copy-pasting the same solution over and over and polluting your code.","title":"TL;DR"},{"location":"middlewares/middleware/#the-big-picture","text":"You can picture this like a wrapped input: No middleware: Source -> Input Adding a layer of middleware: Source -> Middleware ( Input ) Adding n layers of middleware: Source -> Middleware ( Middleware (... Middleware ( Input )...)) Every layer of Middleware forwards its input to its wrapped inner core (whether its the actual Input , or just another layer of Middleware ). Whether or not an Input is wrapped in Middlewares is unknown to the Source .","title":"The big picture"},{"location":"middlewares/middleware/#the-base-idea","text":"Consider the Consumer < T > interface: package io.reactivex.functions ; /** * A functional interface (callback) that accepts a single value. * @param <T> the value type */ public interface Consumer < T > { /** * Consume the given value. * @param t the value * @throws Exception on error */ void accept ( T t ) throws Exception ; } We can easily create a wrapper layer around it: abstract class Middleware < T >( private val wrapped : Consumer < T > ) : Consumer < T > { override fun accept ( t : T ) { // do whatever you want before passing it to wrapped... wrapped . accept ( t ) // ... or after it // ... or even modify what's passed down to wrapped } } Let's play around with it and add some simple implementations: class HelloMiddleware ( private val wrapped : Consumer < String > ) : Middleware < String >( wrapped ) { override fun accept ( t : String ) { wrapped . accept ( \"Hello $t\" ) } } class ReverserMiddleware ( private val wrapped : Consumer < String > ) : Middleware < String >( wrapped ) { override fun accept ( t : String ) { wrapped . accept ( t . reversed ()) } } class LoggingMiddleware < T >( private val wrapped : Consumer < T >, private val logger : ( String ) -> Unit ) : Middleware < T >( wrapped ) { override fun accept ( t : T ) { logger . invoke ( \"LoggingMiddleware: element - $t\" ) wrapped . accept ( t ) } } Now we can compose them and take them for a test ride: val target : Consumer < String > = TODO () val wrappedWithMiddlewares : Consumer < String > = ReverserMiddleware ( HelloMiddleware ( LoggingMiddleware ( { System . out . println ( it ) }, target ) ) ) wrappedWithMiddlewares . accept ( \"MVICore\" ) // Should output to console: // \"LoggingMiddleware: element - Hello orecIVM!\" Explanation: the order in which an element is passing through the Middleware layers is from the outermost -> inwards. In the above example this means that the passed in string: gets reversed gets decorated with Hello %s! gets logged","title":"The base idea"},{"location":"middlewares/playbackmiddleware/","text":"PlaybackMiddleware - The engine of the Time Travel Debugger \u00b6 Time Travel Debugging - out of the box \u00b6 MVICore comes with a configurable PlaybackMiddleware that you can use right away. val playbackMiddleware = PlaybackMiddleware ( wrapped = consumer , recordStore = recordStore , logger = { System . out . println ( it ) } // optional ) The parameter recordStore should be an instance of PlaybackMiddleware . RecordStore . There's currently one implementation inside the library for that: val recordStore = MemoryRecordStore ( playbackScheduler = AndroidSchedulers . mainThread (), logger = { System . out . println () } // optional ) Since this is an in-memory implementation, it will not survive app crashes. This makes it somewhat limited, but for most cases it should be enough (when you have a crash, at least you have a stacktrace - the more difficult cases are when you don't, but still have to figure out what's going wrong). Implementations that record to a persistent storage / network are on the roadmap (contributions welcome). How to use \u00b6 Setup \u00b6 Create your RecordStore instance Create your PlaybackMiddleware factory, passing in your RecordStore Add a rule when your middleware should be used as seen in Middleware configurations You can either call .wrap () on a Consumer < T > or let Binder do it automatically as seen in Automatic wrapping of reactive components with Middlewares The manual way \u00b6 Create a record manually: Holding on to your RecordStore instance (should be the same reference you passed to your PlaybackMiddleware ), call .startRecording () on it. This will record all elements that pass through on any of the Consumer < T > instances wrapped PlaybackMiddleware . Call .stopRecording () when you are done. Replay a record manually: Get a list of recorded and available channels from your RecordStore by calling fun records (): Observable < List < RecordKey >> on it. This is an Observable as if any of the channels are disposed in the meantime, they are removed from the RecordStore to prevent memory leaks. Select a RecordKey from the list. You can use its name field to find the one you are looking for - it should contain the name of the wrapping you used when you called a consumer . wrap ( \"Name\" ) or when you created a binding using `binder.bind(source to target named \"Name\") Call playback ( recordKey ) on RecordStore . The automatic way \u00b6 If you are on Android and using DebugDrawer , you can find a UI control module you can add to it in the mvicore - debugdrawer dependency. UI controls include: start recording stop recording start playback record selection dropdown, which automatically updates itself with all records available in the RecordStore A word about playback \u00b6 As said, RecordStore will record all channels, but can only play back one channel at a time, which you have to select (either with the UI controls, or with a RecordKey from code). This is by design. Imagine a case, where you have (A), (B), (C) components wired in a way that any element passed to (A) will trigger a chain reaction that trickles down all the way to UI. // input --> (A) --> (B) --> (C) --> UI binder . bind ( intput to A ) binder . bind ( A to B ) binder . bind ( B to C ) binder . bind ( C to UI ) Let's assume we add PlaybackMiddleware on all the right ends of the arrows to record elements. If you play back elements to (A), it will trigger all inputs to (B), which in turn will trigger (C), which in turn will talk to the UI, as a result of the chain reaction. If you played back elements simultaneously on all channels: (A) would be fine receiving its own playback (B) would receive 2x elements: both from its own playback, and ones triggered from (A)'s playback (C) would receive 3x elements: elements from its own playback, elements triggered from (B)'s playback, and elements triggered from (A)'s playback that triggered new elements in (B) UI would receive 4x as many elements as intended Limiting playback to one channel is still enough for you to play detective when something goes wrong: Attach a runtime debugger, set a breakpoint, play back input channel for that component and check what's happening there. If the problem is not there, pick another component and play back elements to its input. Rinse and repeat. You might have cases where you are sure that you could replay multiple channels simultaneously that wouldn't affect each other (e.g. navigation events and view models rendered). Support for multi-channel playback in such cases will be added in later versions.","title":"PlaybackMiddleware"},{"location":"middlewares/playbackmiddleware/#playbackmiddleware-the-engine-of-the-time-travel-debugger","text":"","title":"PlaybackMiddleware - The engine of the Time Travel Debugger"},{"location":"middlewares/playbackmiddleware/#time-travel-debugging-out-of-the-box","text":"MVICore comes with a configurable PlaybackMiddleware that you can use right away. val playbackMiddleware = PlaybackMiddleware ( wrapped = consumer , recordStore = recordStore , logger = { System . out . println ( it ) } // optional ) The parameter recordStore should be an instance of PlaybackMiddleware . RecordStore . There's currently one implementation inside the library for that: val recordStore = MemoryRecordStore ( playbackScheduler = AndroidSchedulers . mainThread (), logger = { System . out . println () } // optional ) Since this is an in-memory implementation, it will not survive app crashes. This makes it somewhat limited, but for most cases it should be enough (when you have a crash, at least you have a stacktrace - the more difficult cases are when you don't, but still have to figure out what's going wrong). Implementations that record to a persistent storage / network are on the roadmap (contributions welcome).","title":"Time Travel Debugging - out of the box"},{"location":"middlewares/playbackmiddleware/#how-to-use","text":"","title":"How to use"},{"location":"middlewares/playbackmiddleware/#setup","text":"Create your RecordStore instance Create your PlaybackMiddleware factory, passing in your RecordStore Add a rule when your middleware should be used as seen in Middleware configurations You can either call .wrap () on a Consumer < T > or let Binder do it automatically as seen in Automatic wrapping of reactive components with Middlewares","title":"Setup"},{"location":"middlewares/playbackmiddleware/#the-manual-way","text":"Create a record manually: Holding on to your RecordStore instance (should be the same reference you passed to your PlaybackMiddleware ), call .startRecording () on it. This will record all elements that pass through on any of the Consumer < T > instances wrapped PlaybackMiddleware . Call .stopRecording () when you are done. Replay a record manually: Get a list of recorded and available channels from your RecordStore by calling fun records (): Observable < List < RecordKey >> on it. This is an Observable as if any of the channels are disposed in the meantime, they are removed from the RecordStore to prevent memory leaks. Select a RecordKey from the list. You can use its name field to find the one you are looking for - it should contain the name of the wrapping you used when you called a consumer . wrap ( \"Name\" ) or when you created a binding using `binder.bind(source to target named \"Name\") Call playback ( recordKey ) on RecordStore .","title":"The manual way"},{"location":"middlewares/playbackmiddleware/#the-automatic-way","text":"If you are on Android and using DebugDrawer , you can find a UI control module you can add to it in the mvicore - debugdrawer dependency. UI controls include: start recording stop recording start playback record selection dropdown, which automatically updates itself with all records available in the RecordStore","title":"The automatic way"},{"location":"middlewares/playbackmiddleware/#a-word-about-playback","text":"As said, RecordStore will record all channels, but can only play back one channel at a time, which you have to select (either with the UI controls, or with a RecordKey from code). This is by design. Imagine a case, where you have (A), (B), (C) components wired in a way that any element passed to (A) will trigger a chain reaction that trickles down all the way to UI. // input --> (A) --> (B) --> (C) --> UI binder . bind ( intput to A ) binder . bind ( A to B ) binder . bind ( B to C ) binder . bind ( C to UI ) Let's assume we add PlaybackMiddleware on all the right ends of the arrows to record elements. If you play back elements to (A), it will trigger all inputs to (B), which in turn will trigger (C), which in turn will talk to the UI, as a result of the chain reaction. If you played back elements simultaneously on all channels: (A) would be fine receiving its own playback (B) would receive 2x elements: both from its own playback, and ones triggered from (A)'s playback (C) would receive 3x elements: elements from its own playback, elements triggered from (B)'s playback, and elements triggered from (A)'s playback that triggered new elements in (B) UI would receive 4x as many elements as intended Limiting playback to one channel is still enough for you to play detective when something goes wrong: Attach a runtime debugger, set a breakpoint, play back input channel for that component and check what's happening there. If the problem is not there, pick another component and play back elements to its input. Rinse and repeat. You might have cases where you are sure that you could replay multiple channels simultaneously that wouldn't affect each other (e.g. navigation events and view models rendered). Support for multi-channel playback in such cases will be added in later versions.","title":"A word about playback"},{"location":"middlewares/wrapping/","text":"Automatic wrapping of reactive components with Middlewares \u00b6 The power of Consumer < T > \u00b6 Remember when in the Core concepts we said that Feature is a Consumer of Wish and an ObservableSource of State ? And that in general, the framework is working with outputs of type ObservableSource < T > and inputs of type Consumer < T > ? Now this comes really handy. There's a Kotlin extension method to wrap any Consumer < T : Any > object with Middlewares : val target : Consumer < T > = TODO () // without name target . wrap () // or with name target . wrap ( \"Target input\" ) In essence, you can add Middlewares to just about anything you want if it implements Consumer < T > . What Middlewares? \u00b6 The list of Middlewares that will be applied can be customised flexibly by name, package name, and lots of other conditions (including your own) as we we'll see in the next chapter: 3. Middleware configurations Middlewares for Features - out of the box \u00b6 As an extra, the BaseFeature implementation is also using Consumer < T > internally for its components. That means, you can add Middlewares to not just the Reducer , but the Actor , Bootstrapper , PostProcessor , and NewsPublisher as well. These wrappings will be named: com.example.myapp.MyCoolFeature.BootstrapperImpl.output com.example.myapp.MyCoolFeature.ActorImpl.input com.example.myapp.MyCoolFeature.ReducerImpl.input com.example.myapp.MyCoolFeature.PostProcessorImpl.input com.example.myapp.MyCoolFeature.NewsPublisherImpl.input Middlewares for bindings - out of the box \u00b6 Whenever you create bindings, you get free Middlewares : binder . bind ( source to target ) binder . bind ( source to target using transformer ) Since target here is always a Consumer < T > , Binder can automatically invoke .wrap () on it. These wrappings will have a name containing the connection name, the source and the target: ANONYMOUS ( SourceObject . toString () --> TargetObject.toString()\") . If you want descriptive names for the connection part instead of ANONYMOUS, remember that you can use your own: binder . bind ( source to target named \"MyTarget.ViewModels\" ) binder . bind ( source to target using transformer \"\" MyTarget . ViewModels \")","title":"Automatic wrapping of reactive components with Middlewares"},{"location":"middlewares/wrapping/#automatic-wrapping-of-reactive-components-with-middlewares","text":"","title":"Automatic wrapping of reactive components with Middlewares"},{"location":"middlewares/wrapping/#the-power-of-consumert","text":"Remember when in the Core concepts we said that Feature is a Consumer of Wish and an ObservableSource of State ? And that in general, the framework is working with outputs of type ObservableSource < T > and inputs of type Consumer < T > ? Now this comes really handy. There's a Kotlin extension method to wrap any Consumer < T : Any > object with Middlewares : val target : Consumer < T > = TODO () // without name target . wrap () // or with name target . wrap ( \"Target input\" ) In essence, you can add Middlewares to just about anything you want if it implements Consumer < T > .","title":"The power of Consumer&lt;T&gt;"},{"location":"middlewares/wrapping/#what-middlewares","text":"The list of Middlewares that will be applied can be customised flexibly by name, package name, and lots of other conditions (including your own) as we we'll see in the next chapter: 3. Middleware configurations","title":"What Middlewares?"},{"location":"middlewares/wrapping/#middlewares-for-features-out-of-the-box","text":"As an extra, the BaseFeature implementation is also using Consumer < T > internally for its components. That means, you can add Middlewares to not just the Reducer , but the Actor , Bootstrapper , PostProcessor , and NewsPublisher as well. These wrappings will be named: com.example.myapp.MyCoolFeature.BootstrapperImpl.output com.example.myapp.MyCoolFeature.ActorImpl.input com.example.myapp.MyCoolFeature.ReducerImpl.input com.example.myapp.MyCoolFeature.PostProcessorImpl.input com.example.myapp.MyCoolFeature.NewsPublisherImpl.input","title":"Middlewares for Features - out of the box"},{"location":"middlewares/wrapping/#middlewares-for-bindings-out-of-the-box","text":"Whenever you create bindings, you get free Middlewares : binder . bind ( source to target ) binder . bind ( source to target using transformer ) Since target here is always a Consumer < T > , Binder can automatically invoke .wrap () on it. These wrappings will have a name containing the connection name, the source and the target: ANONYMOUS ( SourceObject . toString () --> TargetObject.toString()\") . If you want descriptive names for the connection part instead of ANONYMOUS, remember that you can use your own: binder . bind ( source to target named \"MyTarget.ViewModels\" ) binder . bind ( source to target using transformer \"\" MyTarget . ViewModels \")","title":"Middlewares for bindings - out of the box"}]}